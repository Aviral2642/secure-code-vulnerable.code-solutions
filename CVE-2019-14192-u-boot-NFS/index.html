<!DOCTYPE html>
<html>
<head>
  <title>CVE-2019-14192 - u-boot NFS</title>
  <meta charset="UTF-8">
</head>
<body>
  <h2>Challenge: CVE-2019-14192 - u-boot NFS</h2>
  <p><strong>Question:</strong> Is this an integer overflow or underflow?</p>

  <input type="text" id="userAnswer" placeholder="Enter your answer">
  <button onclick="checkAnswer()">Submit</button>

  <div id="solution" style="display:none; margin-top:20px;"></div>

  <h4>Challenge Description:</h4>
  <p>The Universal Bootloader (u-boot) is used primarily on embedded systems to load a full OS like Linux. u-boot supports fetching the OS from the network via the Network File System (NFS) protocol (which runs on top of UDP/IP).</p>

  <h4>Full Vulnerable Code:</h4>
  <pre>
////ACID: in_packet
void net_process_received_packet(uchar *in_packet, int len)
{
	struct ethernet_hdr *et;
	struct ip_udp_hdr *ip;
	struct in_addr dst_ip;
	struct in_addr src_ip;
	int eth_proto;
	// ...
	ip = (struct ip_udp_hdr *)(in_packet + E802_HDR_SIZE);
	// ...
	switch (eth_proto) {
	// ...
	case PROT_IP:
		debug_cond(DEBUG_NET_PKT, "Got IP\n");
		if (len < IP_UDP_HDR_SIZE) {
			debug("len bad %d < %lu\n", len,
				  (ulong)IP_UDP_HDR_SIZE);
			return;
		}
		if (len < ntohs(ip->ip_len)) {
			debug("len bad %d < %d\n", len, ntohs(ip->ip_len));
			return;
		}
		len = ntohs(ip->ip_len);
		ip = net_defragment(ip, &len);
		if (!ip)
			return;
		if (ip->ip_p == IPPROTO_ICMP) {
			receive_icmp(ip, len, src_ip, et);
			return;
		} else if (ip->ip_p != IPPROTO_UDP) {
			return;
		}
#if defined(CONFIG_NETCONSOLE) && !defined(CONFIG_SPL_BUILD)
		nc_input_packet((uchar *)ip + IP_UDP_HDR_SIZE,
				src_ip,
				ntohs(ip->udp_dst),
				ntohs(ip->udp_src),
				ntohs(ip->udp_len) - UDP_HDR_SIZE);
#endif
		(*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE,
					  ntohs(ip->udp_dst),
					  src_ip,
					  ntohs(ip->udp_src),
					  ntohs(ip->udp_len) - UDP_HDR_SIZE);
		break;
	}
}
</pre>

  <script>
	async function checkAnswer() {
	  const correctHash = "9a8643223f734fd706b06ff5b7ed3cc6eda4caa701bd85cdff8e8c61b1d88685";
	  const userInput = document.getElementById("userAnswer").value.trim().toLowerCase();

	  const encoder = new TextEncoder();
	  const data = encoder.encode(userInput);
	  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
	  const hashArray = Array.from(new Uint8Array(hashBuffer));
	  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

	  if (hashHex === correctHash) {
		alert("✅ Correct answer! Scroll down to see the solution and explanation.");

		fetch("solution.json")
		  .then(response => response.json())
		  .then(data => {
			const decoded = decodeURIComponent(escape(atob(data.content)));
			document.getElementById("solution").innerHTML = decoded;
			document.getElementById("solution").style.display = "block";
			document.getElementById("solution").scrollIntoView({ behavior: "smooth" });
		  });
	  } else {
		alert("❌ Incorrect. Try again!");
	  }
	}
  </script>
</body>
</html>

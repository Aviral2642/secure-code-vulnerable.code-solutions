
<!DOCTYPE html>
<html>
<head>
  <title>CVE-2019-14192 - u-boot NFS</title>
  <meta charset="UTF-8">
</head>
<body>
  <h2>Challenge: CVE-2019-14192 - u-boot NFS</h2>
  <p><strong>Question:</strong> Is this an integer overflow or underflow?</p>

  <input type="text" id="userAnswer" placeholder="Enter your answer">
  <button onclick="checkAnswer()">Submit</button>

  <div id="solution" style="display:none; margin-top:20px;">
    <h3>✅ Correct!</h3>
    <h4>Challenge Description:</h4>
    <p>The Universal Bootloader (u-boot) is used primarily on embedded systems to load a full OS like Linux. u-boot supports fetching the OS from the network via the Network File System (NFS) protocol (which runs on top of UDP/IP).</p>

    <h4>Full Vulnerable Code:</h4>
<pre>
////ACID: in_packet
void net_process_received_packet(uchar *in_packet, int len)
{
	struct ethernet_hdr *et;
	struct ip_udp_hdr *ip;
	struct in_addr dst_ip;
	struct in_addr src_ip;
	int eth_proto;
	// ...
	ip = (struct ip_udp_hdr *)(in_packet + E802_HDR_SIZE);
	// ...
	switch (eth_proto) {
	// ...
	case PROT_IP:
		debug_cond(DEBUG_NET_PKT, "Got IP\n");
		/* Before we start poking the header, make sure it is there */
		if (len &lt; IP_UDP_HDR_SIZE) {
			debug("len bad %d &lt; %lu\n", len,
			      (ulong)IP_UDP_HDR_SIZE);
			return;
		}
		/* Check the packet length */
		if (len &lt; ntohs(ip-&gt;ip_len)) {
			debug("len bad %d &lt; %d\n", len, ntohs(ip-&gt;ip_len));
			return;
		}
		len = ntohs(ip-&gt;ip_len);
		// ...
		ip = net_defragment(ip, &len);
		if (!ip)
			return;
		// ...
		if (ip-&gt;ip_p == IPPROTO_ICMP) {
			receive_icmp(ip, len, src_ip, et);
			return;
		} else if (ip-&gt;ip_p != IPPROTO_UDP) {	/* Only UDP packets */
			return;
		}

		// ...
#if defined(CONFIG_NETCONSOLE) &amp;&amp; !defined(CONFIG_SPL_BUILD)
		nc_input_packet((uchar *)ip + IP_UDP_HDR_SIZE,
				src_ip,
				ntohs(ip-&gt;udp_dst),
				ntohs(ip-&gt;udp_src),
				ntohs(ip-&gt;udp_len) - UDP_HDR_SIZE);
#endif
		/*
		 * IP header OK.  Pass the packet to the current handler.
		 */
		(*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE,
				      ntohs(ip-&gt;udp_dst),
				      src_ip,
				      ntohs(ip-&gt;udp_src),
				      ntohs(ip-&gt;udp_len) - UDP_HDR_SIZE);
		break;
		// ...
	}
}
</pre>

<h4>Answers:</h4>
<ul>
  <li><b>Which pointer is causing the vulnerability?</b> <code>ip->udp_len</code></li>
  <li><b>What is the line where the vulnerability happens?</b> <code>47</code></li>
  <li><b>Type of vulnerability:</b> <code>underflow</code></li>
</ul>

<h4>Explanation:</h4>
<p>
  The code subtracts <code>UDP_HDR_SIZE</code> (which is 8 bytes) from <code>ip->udp_len</code> without validating that the UDP length is at least 8. 
  If an attacker sets <code>udp_len</code> to a value less than 8, this subtraction will cause an <strong>unsigned integer underflow</strong>. 
  The result is a very large number, which causes the function to process a much larger amount of memory than the actual packet size, 
  potentially leading to a <strong>buffer overflow</strong>. This could be exploited to execute arbitrary code or crash the system.
</p>


  <script>
    function checkAnswer() {
      const correctAnswer = "underflow";
      const userInput = document.getElementById("userAnswer").value.trim().toLowerCase();

      if (userInput === correctAnswer) {
        document.getElementById("solution").style.display = "block";
      } else {
        alert("❌ Incorrect. Try again!");
      }
    }
  </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <title>CVE-2022-26721 - Apple XPC</title>
  <meta charset="UTF-8">
</head>
<body>
  <h2>Challenge: CVE-2022-26721 - Apple XPC ‚ùåüíª</h2>
  <p><strong>Question:</strong> What is the uninitialized data/variable in this code?</p>

  <input type="text" id="userAnswer" placeholder="Enter your answer">
  <button onclick="checkAnswer()">Submit</button>

  <div id="solution" style="display:none; margin-top:20px;"></div>

  <h4>Description:</h4>
  <p>
	Processes on macOS and iOS can use XPC (Mac OS X interProcess Communication) to send data between each other.
	XPC is a serialization mechanism for TLV (Type, Length, Value) encoded data such as dictionaries, arrays, integers, etc.
	The CVMServer daemon accepts various XPC messages, including those that translate OpenGL shaders into native code and return it to clients via executable shared memory.
	CVMServer runs as root and is accessible from the Safari sandbox, making it a critical attack vector for privilege escalation.
  </p>
  <p>
	This challenge explores a case where a patch for a prior integer underflow introduced a UDA (Uninitialized Data Access) vulnerability.
  </p>

  <h4>Vulnerable Code:</h4>
  <pre>
// XENO: CVE-2022-26721 pseudocode
xpc_object_t content = xpc_dictionary_get_value(req, "source");
size_t count = xpc_array_get_count(content);
size_t *descriptors = malloc(sizeof(size_t) * 4 * count);
size_t *accessBeginPointer = &descriptors[count * 0],
  *accessDataLength = &descriptors[count * 1],
  *mappedBaseAddress = &descriptors[count * 2],
  *mappedLength = &descriptors[count * 3];

for(size_t i = 0; i < count; i++) {
  accessBeginPointer[i] = accessDataLength[i] =
  mappedBaseAddress[i] = mappedLength[i] = 0;

  xpc_object_t chunk = xpc_array_get_value(content, i);

  if(xpc_get_type(chunk) == XPC_TYPE_DATA) { /*...*/ }
  else if(xpc_get_type(chunk) == XPC_TYPE_SHMEM) {
	xpc_object_t map = xpc_array_get_value(chunk, 0);
	size_t offset = min(xpc_array_get_uint64(chunk, 1), 0xFFF),
	size = xpc_array_get_uint64(chunk, 2);

	size_t mapped_address;
	size_t mapped_size = xpc_shmem_map(map, &mapped_address);

	if(mapped_size < offset) break;

	size = min(size, mapped_size - offset);
	// ...
  }
}

// cleanup
for(size_t index = 0; index < count; index++) {
  if(mappedLength[index]) {
	munmap(
	  mappedBaseAddress[index],
	  mappedLength[index]
	);
  }
}
free(descriptors);
  </pre>

  <script>
	async function checkAnswer() {
	  const correctHash = "12b2fdc0a0ffd6ce4b7d74d080cd8dcb1c60b6e8f365fb46ac511c46cc31f1c1";
	  const userInput = document.getElementById("userAnswer").value.trim().toLowerCase();

	  const encoder = new TextEncoder();
	  const data = encoder.encode(userInput);
	  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
	  const hashArray = Array.from(new Uint8Array(hashBuffer));
	  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

	  if (hashHex === correctHash) {
		alert("‚úÖ Correct answer! Scroll down to see the solution and explanation.");

		fetch("solution.json")
		  .then(response => response.json())
		  .then(data => {
			const decoded = decodeURIComponent(escape(atob(data.content)));
			document.getElementById("solution").innerHTML = decoded;
			document.getElementById("solution").style.display = "block";
			document.getElementById("solution").scrollIntoView({ behavior: "smooth" });
		  });
	  } else {
		alert("‚ùå Incorrect. Try again!");
	  }
	}
  </script>
</body>
</html>

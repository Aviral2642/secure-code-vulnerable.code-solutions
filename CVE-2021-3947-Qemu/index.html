<!DOCTYPE html>
<html>
<head>
  <title>CVE-2021-3947 - QEMU</title>
  <meta charset="UTF-8">
</head>
<body>
  <h2>Challenge: CVE-2021-3947 - QEMU</h2>
  <p><strong>Question:</strong> What is this vulnerability?</p>

  <input type="text" id="userAnswer" placeholder="Enter your answer">
  <button onclick="checkAnswer()">Submit</button>

  <div id="solution" style="display:none; margin-top:20px;">
	<h3>✅ Correct!</h3>

	<h4>Description:</h4>
	<p>
	  QEMU supports both emulation and virtualization. The NVMe subsystem emulates a virtual controller for high-speed storage.
	  Guest VMs send requests to QEMU's NVMe controller, and QEMU must treat these requests as fully attacker-controlled (ACID).
	  This challenge demonstrates how improper assumptions about memory access size and offset can lead to sensitive memory exposure.
	</p>

	<h4>Vulnerable Code:</h4>
	<pre>
// ACID: buf_len, off, req
static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,
									uint64_t off, NvmeRequest *req)
{
	uint32_t nslist[1024];
	uint32_t trans_len;
	int i = 0;
	uint32_t nsid;

	memset(nslist, 0x0, sizeof(nslist));
	trans_len = MIN(sizeof(nslist) - off, buf_len);

	while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=
			NVME_CHANGED_NSID_SIZE) {
		if (i == ARRAY_SIZE(nslist)) {
			memset(nslist, 0x0, sizeof(nslist));
			nslist[0] = 0xffffffff;
			break;
		}

		nslist[i++] = nsid;
		clear_bit(nsid, n->changed_nsids);
	}

	if (nslist[0] == 0xffffffff) {
		bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);
	}

	if (!rae) {
		nvme_clear_events(n, NVME_AER_TYPE_NOTICE);
	}

	return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);
}

static inline uint16_t nvme_c2h(NvmeCtrl *n, uint8_t *ptr, uint32_t len,
								NvmeRequest *req)
{
	uint16_t status;

	status = nvme_map_dptr(n, &req->sg, len, &req->cmd);
	if (status) {
		return status;
	}

	return nvme_tx(n, &req->sg, ptr, len, NVME_TX_DIRECTION_FROM_DEVICE);
}

static uint16_t nvme_tx(NvmeCtrl *n, NvmeSg *sg, uint8_t *ptr, uint32_t len,
						NvmeTxDirection dir)
{
	assert(sg->flags & NVME_SG_ALLOC);

	if (sg->flags & NVME_SG_DMA) {
		uint64_t residual;

		if (dir == NVME_TX_DIRECTION_TO_DEVICE) {
			residual = dma_buf_write(ptr, len, &sg->qsg);
		} else {
			residual = dma_buf_read(ptr, len, &sg->qsg);
		}

		if (unlikely(residual)) {
			trace_pci_nvme_err_invalid_dma();
			return NVME_INVALID_FIELD | NVME_DNR;
		}
	} else {
		size_t bytes;

		if (dir == NVME_TX_DIRECTION_TO_DEVICE) {
			bytes = qemu_iovec_to_buf(&sg->iov, 0, ptr, len);
		} else {
			bytes = qemu_iovec_from_buf(&sg->iov, 0, ptr, len);
		}

		if (unlikely(bytes != len)) {
			trace_pci_nvme_err_invalid_dma();
			return NVME_INVALID_FIELD | NVME_DNR;
		}
	}

	return NVME_SUCCESS;
	</pre>

	<h4>Answers:</h4>
	<ul>
	  <li><b>What is this vulnerability?</b> <code>info leak</code></li>
	  <li><b>Function lines:</b> <code>58–92</code></li>
	  <li><b>Function name:</b> <code>dma_buf_read</code></li>
	  <li><b>Exact line:</b> <code>70</code></li>
	  <li><b>Is <code>sg->qsg</code> attacker-controlled?</b> <code>yes</code></li>
	</ul>

	<h4>Explanation:</h4>
	<p>
	  The function <code>dma_buf_read</code> performs a read operation using a buffer and length supplied indirectly via attacker input.
	  If <code>off</code> or <code>buf_len</code> are not properly validated, the memory region accessed by <code>ptr + off</code> may leak contents beyond the intended range.
	  This leads to a classic <strong>information disclosure</strong> vulnerability — the guest VM can read data it shouldn't have access to.
	</p>
  </div>

  <script>
	async function checkAnswer() {
	  const correctHash = "2902d0ee0837189885e059e156786fe339faa5f39d0ed2bc2fa708b3848efd46";
	  const userInput = document.getElementById("userAnswer").value.trim().toLowerCase();

	  const encoder = new TextEncoder();
	  const data = encoder.encode(userInput);
	  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
	  const hashArray = Array.from(new Uint8Array(hashBuffer));
	  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

	  if (hashHex === correctHash) {
		document.getElementById("solution").style.display = "block";
	  } else {
		alert("❌ Incorrect. Try again!");
	  }
	}
  </script>
</body>
</html>
